{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ðŸ¥‚ White Wine Quality Prediction: A Machine Learning Approach\n",
    "\n",
    "This notebook follows the same process as our red wine analysis. We will build a machine learning model to predict the quality of white wine based on its chemical properties.\n",
    "\n",
    "1.  **Data Loading and Exploration (EDA)**\n",
    "2.  **Feature Engineering and Preprocessing**\n",
    "3.  **Model Training**\n",
    "4.  **Model Evaluation**\n",
    "5.  **Model Saving** (for API deployment)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1. Data Loading and Exploratory Data Analysis (EDA)\n",
    "\n",
    "First, we load the dataset, noting the specific instruction to use a semicolon (`;`) as the delimiter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--- Dataset Head ---\n",
      "   fixed acidity  volatile acidity  citric acid  ...  sulphates  alcohol  quality\n",
      "0            7.0              0.27         0.36  ...       0.45      8.8        6\n",
      "1            6.3              0.30         0.34  ...       0.49     11.0        6\n",
      "2            8.1              0.28         0.40  ...       0.44     10.1        6\n",
      "3            7.2              0.23         0.32  ...       0.40      9.9        6\n",
      "4            7.2              0.23         0.32  ...       0.40      9.9        6\n",
      "\n",
      "[5 rows x 12 columns]\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.metrics import classification_report, confusion_matrix\n",
    "import joblib # Import joblib for saving the model\n",
    "import warnings\n",
    "\n",
    "# Suppress warnings for cleaner output\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# Set visualization style\n",
    "sns.set(style=\"whitegrid\")\n",
    "\n",
    "# Load the dataset\n",
    "# We must use the 'raw' URL and specify sep=';'\n",
    "url = \"https://raw.githubusercontent.com/SamuelDasaolu/Practice_datasets/main/winequality-white.csv\"\n",
    "wine_df = pd.read_csv(url, sep=';')\n",
    "\n",
    "# Display the first few rows of the dataframe\n",
    "print(\"--- Dataset Head ---\")\n",
    "print(wine_df.head())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, let's examine the dataset's structure and check for any missing values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Dataset Info ---\n",
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 4898 entries, 0 to 4897\n",
      "Data columns (total 12 columns):\n",
      " #   Column                Non-Null Count  Dtype  \n",
      "---  ------                --------------  -----  \n",
      " 0   fixed acidity         4898 non-null   float64\n",
      " 1   volatile acidity      4898 non-null   float64\n",
      " 2   citric acid           4898 non-null   float64\n",
      " 3   residual sugar        4898 non-null   float64\n",
      " 4   chlorides             4898 non-null   float64\n",
      " 5   free sulfur dioxide   4898 non-null   float64\n",
      " 6   total sulfur dioxide  4898 non-null   float64\n",
      " 7   density               4898 non-null   float64\n",
      " 8   pH                    4898 non-null   float64\n",
      " 9   sulphates             4898 non-null   float64\n",
      " 10  alcohol               4898 non-null   float64\n",
      " 11  quality               4898 non-null   int64  \n",
      "dtypes: float64(11), int64(1)\n",
      "memory usage: 459.3 KB\n",
      "\n",
      "--- Missing Values Check ---\n",
      "fixed acidity           0\n",
      "volatile acidity        0\n",
      "citric acid             0\n",
      "residual sugar          0\n",
      "chlorides               0\n",
      "free sulfur dioxide     0\n",
      "total sulfur dioxide    0\n",
      "density                 0\n",
      "pH                      0\n",
      "sulphates               0\n",
      "alcohol                 0\n",
      "quality                 0\n",
      "dtype: int64\n"
     ]
    }
   ],
   "source": [
    "# Get information about the dataframe\n",
    "print(\"\\n--- Dataset Info ---\")\n",
    "wine_df.info()\n",
    "\n",
    "# Check for missing values\n",
    "print(\"\\n--- Missing Values Check ---\")\n",
    "print(wine_df.isnull().sum())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Observation:** The data is clean. We have **4898 entries** (more than the red wine dataset), all 11 features are numeric, and there are **no missing values**.\n",
    "\n",
    "---\n",
    "#### Summary Statistics\n",
    "\n",
    "Let's look at the summary statistics to understand feature scales."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Descriptive Statistics ---\n",
      "       fixed acidity  volatile acidity  citric acid  residual sugar  ...        pH  sulphates     alcohol      quality\n",
      "count    4898.000000       4898.000000  4898.000000     4898.000000  ... 4898.000000  4898.000000  4898.000000  4898.000000\n",
      "mean        6.854788          0.278241     0.334192        6.391415  ...    3.188267     0.489847    10.514267     5.877909\n",
      "std         0.843868          0.100795     0.121020        5.072058  ...    0.151001     0.114126     1.230621     0.885639\n",
      "min         3.800000          0.080000     0.000000        0.600000  ...    2.720000     0.220000     8.000000     3.000000\n",
      "25%         6.300000          0.210000     0.270000        1.700000  ...    3.090000     0.410000     9.500000     5.000000\n",
      "50%         6.800000          0.260000     0.320000        5.200000  ...    3.180000     0.470000    10.400000     6.000000\n",
      "75%         7.300000          0.320000     0.390000        9.900000  ...    3.280000     0.550000    11.400000     6.000000\n",
      "max        14.200000          1.100000     1.660000       65.800000  ...    3.820000     1.080000    14.200000     9.000000\n",
      "\n",
      "[8 rows x 12 columns]\n"
     ]
    }
   ],
   "source": [
    "# Get summary statistics\n",
    "print(\"\\n--- Descriptive Statistics ---\")\n",
    "print(wine_df.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Observation:** Similar to the red wine, the features are on very different scales (e.g., `residual sugar` max is 65.8, `pH` max is 3.82). **Feature scaling is required.**\n",
    "\n",
    "---\n",
    "#### Visualizing the Target Variable\n",
    "\n",
    "Let's see the distribution of our target variable, `quality`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Saved white_quality_distribution.png\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA...AASUVORK5CYII=\n"
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Distribution of the target variable 'quality'\n",
    "plt.figure(figsize=(8, 6))\n",
    "sns.countplot(x='quality', data=wine_df, palette=\"viridis_r\")\n",
    "plt.title('Distribution of White Wine Quality')\n",
    "plt.xlabel('Quality Rating')\n",
    "plt.ylabel('Count')\n",
    "plt.savefig('white_quality_distribution.png')\n",
    "print(\"Saved white_quality_distribution.png\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Observation:** The distribution is again centered on 5 and 6, but there are significantly more wines rated 7 than in the red wine dataset.\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2. Feature Engineering & Preprocessing\n",
    "\n",
    "**Goal:** Simplify the problem for a simple API.\n",
    "\n",
    "We will use the same binary classification strategy as before:\n",
    "* **Bad (0):** Quality rating 6 or less.\n",
    "* **Good (1):** Quality rating 7 or more."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- New Target Variable Distribution ---\n",
      "0    0.783585\n",
      "1    0.216415\n",
      "Name: category, dtype: float64\n",
      "Saved white_category_distribution.png\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAA...AASUVORK5CYII=\n"
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Create a new binary target variable 'category'\n",
    "wine_df['category'] = wine_df['quality'].apply(lambda x: 1 if x >= 7 else 0)\n",
    "\n",
    "# Drop the original 'quality' column as we now have our new target\n",
    "wine_df_processed = wine_df.drop('quality', axis=1)\n",
    "\n",
    "# Check the distribution of our new target variable\n",
    "print(\"\\n--- New Target Variable Distribution ---\")\n",
    "print(wine_df_processed['category'].value_counts(normalize=True))\n",
    "\n",
    "# Visualize the new distribution\n",
    "plt.figure(figsize=(6, 4))\n",
    "sns.countplot(x='category', data=wine_df_processed, palette=\"pastel\")\n",
    "plt.title('Distribution of Wine Category (0=Bad, 1=Good)')\n",
    "plt.xlabel('Wine Category')\n",
    "plt.ylabel('Count')\n",
    "plt.savefig('white_category_distribution.png')\n",
    "print(\"Saved white_category_distribution.png\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Observation:** This dataset is still imbalanced (approx. 78% \"Bad\" and 22% \"Good\"), but it is **less imbalanced** than the red wine dataset (which was 86/14). This should help the model learn to identify \"Good\" wines.\n",
    "\n",
    "---\n",
    "#### Splitting and Scaling the Data\n",
    "\n",
    "Now we separate our features (`X`) from our target (`y`), split the data into training and testing sets, and apply feature scaling."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training set shape: (3918, 11)\n",
      "Test set shape: (980, 11)\n",
      "Data scaling complete.\n"
     ]
    }
   ],
   "source": [
    "# Define features (X) and target (y)\n",
    "X = wine_df_processed.drop('category', axis=1)\n",
    "y = wine_df_processed['category']\n",
    "\n",
    "# Split the data into training and testing sets\n",
    "# We use stratify=y to ensure the class imbalance is preserved in both sets\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)\n",
    "\n",
    "print(f\"Training set shape: {X_train.shape}\")\n",
    "print(f\"Test set shape: {X_test.shape}\")\n",
    "\n",
    "# Scale the features\n",
    "# We fit the scaler ONLY on the training data to prevent data leakage\n",
    "scaler = StandardScaler()\n",
    "X_train_scaled = scaler.fit_transform(X_train)\n",
    "X_test_scaled = scaler.transform(X_test)\n",
    "\n",
    "# The 'scaler' object will be saved for the API\n",
    "print(\"Data scaling complete.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3. Model Selection and Training\n",
    "\n",
    "We'll again use a `RandomForestClassifier` with `class_weight='balanced'` to handle the imbalance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Training the model...\n",
      "Model training complete.\n"
     ]
    }
   ],
   "source": [
    "# Initialize the model\n",
    "model = RandomForestClassifier(random_state=42, class_weight='balanced')\n",
    "\n",
    "# Train the model\n",
    "print(\"Training the model...\")\n",
    "model.fit(X_train_scaled, y_train)\n",
    "print(\"Model training complete.\")\n",
    "\n",
    "# The 'model' object will be saved for the API."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4. Model Evaluation\n",
    "\n",
    "Let's evaluate the model's performance on the unseen test data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Classification Report ---\n",
      "              precision    recall  f1-score   support\n",
      "\n",
      "     Bad (0)       0.95      0.97      0.96       767\n",
      "    Good (1)       0.89      0.82      0.85       213\n",
      "\n",
      "    accuracy                           0.94       980\n",
      "   macro avg       0.92      0.90      0.91       980\n",
      "weighted avg       0.93      0.94      0.93       980\n",
      "\n",
      "\n",
      "--- Confusion Matrix ---\n",
      "[[745  22]\n",
      " [ 38 175]]\n",
      "Saved white_confusion_matrix.png\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAA...AASUVORK5CYII=\n"
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Make predictions on the test set\n",
    "y_pred = model.predict(X_test_scaled)\n",
    "\n",
    "# Generate the classification report\n",
    "print(\"\\n--- Classification Report ---\")\n",
    "print(classification_report(y_test, y_pred, target_names=['Bad (0)', 'Good (1)']))\n",
    "\n",
    "# Generate the confusion matrix\n",
    "print(\"\\n--- Confusion Matrix ---\")\n",
    "cm = confusion_matrix(y_test, y_pred)\n",
    "print(cm)\n",
    "\n",
    "# Visualize the confusion matrix\n",
    "plt.figure(figsize=(7, 5))\n",
    "sns.heatmap(cm, annot=True, fmt='d', cmap='Greens',\n",
    "            xticklabels=['Predicted Bad', 'Predicted Good'],\n",
    "            yticklabels=['Actual Bad', 'Actual Good'])\n",
    "plt.title('Confusion Matrix - White Wine')\n",
    "plt.ylabel('Actual Label')\n",
    "plt.xlabel('Predicted Label')\n",
    "plt.savefig('white_confusion_matrix.png')\n",
    "print(\"Saved white_confusion_matrix.png\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5. Interpretation & Conclusion\n",
    "\n",
    "The model for white wine performs **exceptionally well**, much better than the red wine model.\n",
    "\n",
    "* **Accuracy (94%):** Very high.\n",
    "* **Precision (Good = 0.89):** When the model predicts \"Good,\" it's right 89% of the time. (Excellent!)\n",
    "* **Recall (Good = 0.82):** The model finds 82% of all actual \"Good\" wines. (Very strong!)\n",
    "* **F1-Score (Good = 0.85):** A very high balanced score.\n",
    "* **Confusion Matrix:**\n",
    "    * **False Positives (22):** Very few \"Bad\" wines were mislabeled as \"Good.\"\n",
    "    * **False Negatives (38):** Only 38 \"Good\" wines were missed (labeled \"Bad\").\n",
    "\n",
    "This model is significantly more reliable, likely due to the larger dataset (4898 rows vs. 1599) and the less severe class imbalance (22% \"Good\" vs. 14%).\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 6. Save Model and Scaler for API\n",
    "\n",
    "This is the final step. We save the `model` and `scaler` objects with new names to distinguish them from the red wine models."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Saving model and scaler to disk...\n",
      "Files saved successfully: 'white_wine_model.joblib' and 'white_wine_scaler.joblib'\n"
     ]
    }
   ],
   "source": [
    "# Save the model and scaler\n",
    "print(\"\\nSaving model and scaler to disk...\")\n",
    "joblib.dump(model, 'white_wine_model.joblib')\n",
    "joblib.dump(scaler, 'white_wine_scaler.joblib')\n",
    "print(\"Files saved successfully: 'white_wine_model.joblib' and 'white_wine_scaler.joblib'\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}